b"Source: https://bugs.chromium.org/p/project-zero/issues/detail?id=926\n\nmach ports are really struct ipc_port_t's in the kernel; this is a reference-counted object,\nip_reference and ip_release atomically increment and decrement the 32 bit io_references field.\n\nUnlike OSObjects, ip_reference will allow the reference count to overflow, however it is still 32-bits\nso without either a lot of physical memory (which you don't have on mobile or most desktops) or a real reference leak\nthis isn't that interesting.\n\n** MIG and mach message rights ownership **\n\nipc_kobject_server in ipc_kobject.c is the main dispatch routine for the kernel MIG endpoints. When userspace sends a\nmessage the kernel will copy in the message body and also copy in all the message rights; see for example\nipc_right_copyin in ipc_right.c. This means that by the time we reach the actual callout to the MIG handler any port rights\ncontained in a request have had their reference count increased by one.\n\nAfter the callout we reach the following code (still in ipc_kobject_server):\n\n    if ((kr == KERN_SUCCESS) || (kr == MIG_NO_REPLY)) {\n         //  The server function is responsible for the contents\n         //  of the message.  The reply port right is moved\n         //  to the reply message, and we have deallocated\n         //  the destination port right, so we just need\n         //  to free the kmsg.\n        ipc_kmsg_free(request);\n    } else {\n         //  The message contents of the request are intact.\n         //  Destroy everthing except the reply port right,\n         //  which is needed in the reply message.\n        request->ikm_header->msgh_local_port = MACH_PORT_NULL;\n        ipc_kmsg_destroy(request);\n    }\n\nIf the MIG callout returns success, then it means that the method took ownership of *all* of the rights contained in the message.\nIf the MIG callout returns a failure code then the means the method took ownership of *none* of the rights contained in the message.\n\nipc_kmsg_free will only destroy the message header, so if the message had any other port rights then their reference counts won't be\ndecremented. ipc_kmsg_destroy on the other hand will decrement the reference counts for all the port rights in the message, even those\nin port descriptors.\n\nIf we can find a MIG method which returns KERN_SUCCESS but doesn't in fact take ownership of any mach ports its passed (by for example\nstoring them and dropping the ref later, or using them then immediately dropping the ref or passing them to another method which takes\nownership) then this can lead to us being able to leak references.\n\n** indirect MIG methods **\n\nHere's the MIG request structure generated for io_service_add_notification_ool_64:\n\n  typedef struct {\n          mach_msg_header_t Head;\n          // start of the kernel processed data\n          mach_msg_body_t msgh_body;\n          mach_msg_ool_descriptor_t matching;\n          mach_msg_port_descriptor_t wake_port;\n          // end of the kernel processed data\n          NDR_record_t NDR;\n          mach_msg_type_number_t notification_typeOffset; // MiG doesn't use it\n          mach_msg_type_number_t notification_typeCnt;\n          char notification_type[128];\n          mach_msg_type_number_t matchingCnt;\n          mach_msg_type_number_t referenceCnt;\n          io_user_reference_t reference[8];\n          mach_msg_trailer_t trailer;\n  } Request __attribute__((unused));\n\n\nThis is an interesting method as its implementation actually calls another MIG handler:\n\n\n  static kern_return_t internal_io_service_add_notification_ool(\n  ...\n    kr = vm_map_copyout( kernel_map, &map_data, (vm_map_copy_t) matching );\n    data = CAST_DOWN(vm_offset_t, map_data);\n\n    if( KERN_SUCCESS == kr) {\n      // must return success after vm_map_copyout() succeeds\n      // and mig will copy out objects on success\n      *notification = 0;\n      *result = internal_io_service_add_notification( master_port, notification_type,\n                                                     (char *) data, matchingCnt, wake_port, reference, referenceSize, client64, notification );\n      vm_deallocate( kernel_map, data, matchingCnt );\n    }\n\n    return( kr );\n  }\n\n\nand internal_io_service_add_notification does this:\n\n\n    static kern_return_t internal_io_service_add_notification(\n      ...\n      if( master_port != master_device_port)\n        return( kIOReturnNotPrivileged);\n\n      do {\n        err = kIOReturnNoResources;\n\n        if( !(sym = OSSymbol::withCString( notification_type )))\n          err = kIOReturnNoResources;\n\n        if (matching_size)\n        {\n          dict = OSDynamicCast(OSDictionary, OSUnserializeXML(matching, matching_size));\n        }\n        else\n        {\n          dict = OSDynamicCast(OSDictionary, OSUnserializeXML(matching));\n        }\n\n        if (!dict) {\n          err = kIOReturnBadArgument;\n          continue;\n        }\n      ...\n      } while( false );\n\n      return( err );\n\n\nThis inner function has many failure cases (wrong kernel port, invalid serialized data) which we can easily trigger and these error paths lead\nto this inner function not taking ownership of the wake_port argument. However, MIG will only see the return value of the outer internal_io_service_add_notification_ool\nwhich will always return success if we pass a valid ool memory descriptor. This violates ipc_kobject_server's ownership model where success means ownership\nwas taken of all rights, not just some.\n\nWhat this leads to is actually quite a nice primitive for constructing an ipc_port_t reference count overflow without leaking any memory.\n\nIf we call io_service_add_notification_ool with a valid ool descriptor, but fill it with data that causes OSUnserializeXML to return an error then\nwe can get that memory freed (via the vm_deallocate call above) but the reference on the wake port will be leaked since ipc_kmsg_free will be called, not\nipc_kmsg_destroy.\n\nIf we send this request 0xffffffff times we can cause a ipc_port_t's io_references field to overflow to 0; the next time it's used the ref will go 0 -> 1 -> 0\nand the object will be free'd but we'll still have a dangling pointer in our process's ports table.\n\nAs well as being a regular kernel UaF this also gives us the opportunity to do all kinds of fun mach port related logic attacks, eg getting send rights to\nother task's task ports via our dangling ipc_port_t pointer.\n\n** practicality **\n\nOn my 4 year old dual core MBA 5,2 running with two threads this PoC takes around 8 hours after which you should see a kernel panic indicative of a UaF.\nNote that there are no resources leaks involved here so you can run it even on very constrained systems like an iPhone and it will work fine,\nalbeit a bit slowly :)\n\nThis code is reachable from all sandboxed environments.\n\n** fixes **\n\nOne approach to fixing this issue would be to do something similar to OSObjects which use a saturating reference count and leak the object if the reference count saturates\n\nI fear there are a great number of similar issues so just fixing this once instance may not be enough.\n\n\nProof of Concept:\nhttps://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/40955.zip"