package lang

import (
	"errors"
	"path/filepath"
	"strings"

	"github.com/cybersecsi/exploitdb-images/core/utils"
)

type LangError int

const (
	MISSING_MODULE LangError = iota
	MISSING_DEPS
	VERSION_LANGUAGE_ERROR
)

var (
	ErrNotImplemented = errors.New("Error management not implemented")
)

type Lang interface {
	ErrorStrings() map[LangError][]string
	AddDependency(string, string)
	ManageError(LangError, string) string
}

type Python struct {
}

type Python2 struct{}

type Checker struct {
	language Lang
}

func PythonChecker() Checker {
	checker := Checker{}
	checker.language = new(Python)
	return checker
}
func Python2Checker() Checker {
	checker := Checker{}
	checker.language = new(Python2)
	return checker
}

func (p Python) ErrorStrings() map[LangError][]string {
	return map[LangError][]string{
		MISSING_MODULE:         {"ModuleNotFoundError"},
		VERSION_LANGUAGE_ERROR: {"Missing parentheses", "No module named"}}
}

func (p Python2) ErrorStrings() map[LangError][]string {
	return map[LangError][]string{
		MISSING_MODULE:         {"No module named"},
		VERSION_LANGUAGE_ERROR: {"Missing parentheses"}}
}
func (p Python) AddDependency(exploit_path string, module_name string) {
	utils.Log("PYTHON3")
	utils.AddNewStringToFile(filepath.Join(utils.ImageDestPath(exploit_path), "requirements.txt"), module_name)
}

func (p Python2) AddDependency(exploit_path string, module_name string) {
	pp := new(Python)
	pp.AddDependency(exploit_path, module_name)
}

// Manage the error and return the information
func (p Python) ManageError(langErr LangError, s string) string {
	def := ""
	switch langErr {
	case MISSING_MODULE:
		return utils.BetweenSingleQuotes(s)
	case VERSION_LANGUAGE_ERROR:
	default:
		return def
	}
	return def
}

func (p Python2) ManageError(langErr LangError, s string) string {
	def := ""
	utils.Log("In manager ERROR", s)
	switch langErr {
	case MISSING_MODULE:
		// no module requests: last string is the module name
		return utils.LastString(s)
	case VERSION_LANGUAGE_ERROR:
	default:
		return def
	}
	return def
}

// Discover error and return information that can be useful to perform actions
func (c Checker) DiscoverError(output string) (LangError, string, error) {
	error_strings := c.language.ErrorStrings()
	var nullErr LangError
	var info string
	for key, checkers := range error_strings {
		for _, s := range utils.SplitLines(output) {
			// Navigate all checker string
			for _, element := range checkers {
				if strings.Contains(s, element) {
					utils.Log("String=", s, " checker=", element)
					return key, c.language.ManageError(key, s), nil
				}
			}
		}
	}
	return nullErr, info, ErrNotImplemented
	// not found, return not implemented
}

// Set the language
func (c Checker) SwitchLanguage(l Lang) {
	c.language = l
}

func (c Checker) AddDependency(path string, info string) {
	c.language.AddDependency(path, info)
}
