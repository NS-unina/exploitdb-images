package docker

import (
	"archive/tar"
	"bytes"
	"io/ioutil"
	"path/filepath"

	"github.com/cybersecsi/exploitdb-images/core/utils"

	"context"
	"fmt"
	"io"
	"os"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/strslice"
	"github.com/docker/docker/client"
	"github.com/docker/docker/pkg/archive"
	"github.com/docker/docker/pkg/stdcopy"
)

const (
	PYTHON3_IMAGE = "python:alpine3.15"
)

type ErrorLine struct {
	Error       string      `json:"error"`
	ErrorDetail ErrorDetail `json:"errorDetail"`
}

type ErrorDetail struct {
	Message string `json:"message"`
}

func Init() (cli *client.Client) {
	cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
	if err != nil {
		panic(err)
	}
	return
}

func Images() {
	cli := Init()
	ctx := context.Background()
	images, err := cli.ImageList(ctx, types.ImageListOptions{})
	utils.ErrorHandler(err)

	for _, image := range images {
		fmt.Println(image.ID)
	}
}

func ImageExists(name string) bool {
	cli := Init()
	ctx := context.Background()
	// res, err := cli.ImageSearch(ctx, utils.ImageName(name), types.ImageSearchOptions{Limit: 1})
	// res, err := cli.ImageSearch(ctx, "bfac", types.ImageSearchOptions{Limit: 1})
	res, err := cli.ImageSearch(ctx, "secsi", types.ImageSearchOptions{Limit: 100})
	utils.ErrorHandler(err)
	return len(res) > 0
}

func Pull(name string) {
	cli := Init()
	ctx := context.Background()
	out, err := cli.ImagePull(ctx, name, types.ImagePullOptions{})
	utils.ErrorHandler(err)
	defer out.Close()
	io.Copy(os.Stdout, out)
}

// Create Dockerfile in the proper folder
// TODO: consider also requirements.txt
func CreateDockerfileStructure(path string, lang string, remote_exploit_path string, force bool) {
	dest_path := utils.ImageDestPath(path)
	utils.Log(dest_path)
	if !utils.FileExists(dest_path) || force {
		newMakefile := filepath.Join(dest_path, "Makefile")
		utils.CopyDir(filepath.Join(utils.TemplatePath, lang), dest_path)
		utils.CopyFile(filepath.Join(utils.TemplatePath, "Makefile"), newMakefile)
		utils.ReplaceLineInFile(newMakefile, "{{EXPLOIT_URL}}", remote_exploit_path)
	}
}

func GetContext(filePath string) io.Reader {
	ctx, err := archive.TarWithOptions(filePath, &archive.TarOptions{})
	utils.ErrorHandler(err)
	return ctx
}

// https://www.loginradius.com/blog/async/build-push-docker-images-golang/
func BuildDockerImage(path string, remote_exploit string) (imageName string) {
	dest_path := utils.ImageDestPath(path)
	imageName = utils.ImageName(path)
	cli := Init()
	ctx := context.Background()
	tar, err := archive.TarWithOptions(dest_path, &archive.TarOptions{})
	utils.ErrorHandler(err)
	opts := types.ImageBuildOptions{
		Dockerfile:  "Dockerfile",
		NoCache:     true,
		Remove:      true,
		ForceRemove: true,
		Tags:        []string{imageName},
		BuildArgs: map[string]*string{
			"EXPLOIT_URL": &remote_exploit},
	}
	res, err := cli.ImageBuild(ctx, tar, opts)
	utils.ErrorHandler(err)
	defer res.Body.Close()
	_, err = io.Copy(os.Stdout, res.Body)
	utils.ErrorHandler(err)
	return
}

// func print(rd io.Reader) error {
// 	var lastLine string

// 	scanner := bufio.NewScanner(rd)
// 	for scanner.Scan() {
// 		lastLine = scanner.Text()
// 		fmt.Println(scanner.Text())
// 	}

// 	errLine := &ErrorLine{}
// 	json.Unmarshal([]byte(lastLine), errLine)
// 	if errLine.Error != "" {
// 		return errors.New(errLine.Error)
// 	}

// 	if err := scanner.Err(); err != nil {
// 		return err
// 	}

// 	return nil
// }

// https://stackoverflow.com/questions/38804313/build-docker-image-from-go-code
func _BuildDockerImage(path string, remote_exploit string) (imageName string) {
	dest_path := utils.ImageDestPath(path)
	// dockerBuildContext := GetContext(filepath.Join(dest_path, "tarfile.tar"))
	// buildOptions := types.ImageBuildOptions{
	// 	Dockerfile: filepath.Join(dest_path, "Dockerfile"), // optional, is the default
	// }
	cli := Init()
	ctx := context.Background()
	buf := new(bytes.Buffer)
	tw := tar.NewWriter(buf)
	imageName = utils.ORGANIZATION + "/" + utils.FileNameWithoutExtension(filepath.Base(path))
	defer tw.Close()
	dockerFile := "Dockerfile"
	dockerFileReader, err := os.Open(filepath.Join(dest_path, "Dockerfile"))
	utils.ErrorHandler(err)
	readDockerFile, err := ioutil.ReadAll(dockerFileReader)
	utils.ErrorHandler(err)
	requirementsReader, err := os.Open(filepath.Join(dest_path, "requirements.txt"))
	utils.ErrorHandler(err)
	readRequirements, err := ioutil.ReadAll(requirementsReader)
	tarHeader := &tar.Header{
		Name: dockerFile,
		Size: int64(len(readDockerFile)),
	}
	err = tw.WriteHeader(tarHeader)
	utils.ErrorHandler(err)

	_, err = tw.Write(readDockerFile)
	utils.ErrorHandler(err)
	_, err = tw.Write(readRequirements)
	utils.ErrorHandler(err)

	dockerFileTarReader := bytes.NewReader(buf.Bytes())
	imageBuildResponse, err := cli.ImageBuild(
		ctx,
		dockerFileTarReader,
		types.ImageBuildOptions{
			Context:    dockerFileTarReader,
			Tags:       []string{imageName},
			Dockerfile: dockerFile,
			BuildArgs: map[string]*string{
				"EXPLOIT_URL": &remote_exploit},
			Remove: true})

	utils.ErrorHandler(err)
	defer imageBuildResponse.Body.Close()

	// Print to standard output
	_, err = io.Copy(os.Stdout, imageBuildResponse.Body)
	utils.ErrorHandler(err)
	return
}

// Return the container and host options
func DockerOptions(imageName string, cmd strslice.StrSlice) (*container.Config, *container.HostConfig) {
	containerConfig := container.Config{
		Image:        imageName,
		AttachStdout: true,
		AttachStderr: true,
		Tty:          true,
		Cmd:          cmd}
	// Remove explicitely to read container logs
	hostConfig := container.HostConfig{AutoRemove: false}
	return &containerConfig, &hostConfig
}
func RunContainer(imageName string, containerName string, cmd strslice.StrSlice, autoremove bool) (is_failed bool, output string) {
	ctx := context.Background()
	cli := Init()
	containerConfig, hostConfig := DockerOptions(imageName, cmd)
	resp, err := cli.ContainerCreate(ctx, containerConfig, hostConfig, nil, nil, containerName)
	utils.ErrorHandler(err)
	err = cli.ContainerStart(ctx, resp.ID, types.ContainerStartOptions{})
	utils.ErrorHandler(err)
	statusCh, errCh := cli.ContainerWait(ctx, resp.ID, container.WaitConditionNotRunning)
	select {
	case err := <-errCh:
		utils.ErrorHandler(err)
	case status := <-statusCh:
		// TODO: CHECK OTHER CONDITIONS
		is_failed = status.StatusCode != 0 && status.StatusCode != 2
	}
	reader, err := cli.ContainerLogs(ctx, resp.ID, types.ContainerLogsOptions{ShowStdout: true, ShowStderr: true, Follow: true})
	utils.ErrorHandler(err)
	defer reader.Close()
	stdcopy.StdCopy(os.Stdout, os.Stderr, reader)
	content, err := ioutil.ReadAll(reader)
	if err != nil && autoremove {
		err2 := cli.ContainerRemove(ctx, resp.ID, types.ContainerRemoveOptions{RemoveVolumes: true, Force: true})
		utils.ErrorHandler(err)
		utils.ErrorHandler(err2)
	}
	err = cli.ContainerRemove(ctx, resp.ID, types.ContainerRemoveOptions{RemoveVolumes: true, Force: true})
	utils.ErrorHandler(err)
	output = string(content)
	// Return the content string
	return is_failed, output
}

// Test the execution of a command
func TestExploit(imageName string) (is_failed bool, output string) {
	containerName := filepath.Base(imageName)
	return RunContainer(imageName, containerName, nil, true)
}

// Test a run command
func TestRunCmd(imageName string, containerName string, cmd strslice.StrSlice) (is_failed bool, output string) {
	return RunContainer(imageName, containerName, cmd, true)
}

func CanPipModuleBeInstalled(module string) (can_be_installed bool) {
	is_failed, _ := TestRunCmd(PYTHON3_IMAGE, "python", []string{"sh", "-c", fmt.Sprint("pip install", module)})
	return is_failed == false
}
