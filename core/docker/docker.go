package docker

import (
	"archive/tar"
	"bytes"
	"io/ioutil"
	"path/filepath"
	"runtime"

	"github.com/cybersecsi/exploitdb-images/core/utils"

	"context"
	"fmt"
	"io"
	"os"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/client"
	"github.com/docker/docker/pkg/archive"
	"github.com/docker/docker/pkg/stdcopy"
)

var (
	_, b, _, _   = runtime.Caller(0)
	basepath     = filepath.Dir(b)
	root         = filepath.Join(filepath.Dir(b), "../..")
	templatePath = filepath.Join(root, "assets", "templates")
	imagePath    = filepath.Join(root, "images")
)

func Init() (cli *client.Client) {
	cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
	if err != nil {
		panic(err)
	}
	return
}

func Images() {
	cli := Init()
	ctx := context.Background()
	images, err := cli.ImageList(ctx, types.ImageListOptions{})
	utils.ErrorHandler(err)

	for _, image := range images {
		fmt.Println(image.ID)
	}
}

func ImageExists(name string) bool {
	cli := Init()
	ctx := context.Background()
	// res, err := cli.ImageSearch(ctx, utils.ImageName(name), types.ImageSearchOptions{Limit: 1})
	// res, err := cli.ImageSearch(ctx, "bfac", types.ImageSearchOptions{Limit: 1})
	res, err := cli.ImageSearch(ctx, "secsi", types.ImageSearchOptions{Limit: 100})

	fmt.Println(res)
	utils.ErrorHandler(err)
	return len(res) > 0
}

func Pull(name string) {
	cli := Init()
	ctx := context.Background()
	out, err := cli.ImagePull(ctx, name, types.ImagePullOptions{})
	utils.ErrorHandler(err)
	defer out.Close()
	io.Copy(os.Stdout, out)
}

func DestPath(path string) string {
	path_folder := filepath.Dir(path)
	file_name := filepath.Base(path)
	dest_path := filepath.Join(imagePath, path_folder, utils.FileNameWithoutExtension(file_name))
	return dest_path
}
func CreateDockerfile(path string) {
	dest_path := DestPath(path)
	utils.Log(dest_path)
	err := os.MkdirAll(dest_path, 0755)
	utils.ErrorHandler(err)
	utils.CopyFile(filepath.Join(templatePath, "python.Dockerfile"), filepath.Join(dest_path, "Dockerfile"))
	// to_write := filepath.Join(imagePath, path)
	// err = os.WriteFile(to_write, []byte(exploit_code), 0644)
	// utils.ErrorHandler(err)

}

func GetContext(filePath string) io.Reader {
	ctx, err := archive.TarWithOptions(filePath, &archive.TarOptions{})
	utils.ErrorHandler(err)
	return ctx
}

// https://stackoverflow.com/questions/38804313/build-docker-image-from-go-code
func BuildDockerImage(path string, remote_exploit string) (imageName string) {
	dest_path := DestPath(path)
	// dockerBuildContext := GetContext(filepath.Join(dest_path, "tarfile.tar"))
	// buildOptions := types.ImageBuildOptions{
	// 	Dockerfile: filepath.Join(dest_path, "Dockerfile"), // optional, is the default
	// }
	cli := Init()
	ctx := context.Background()
	buf := new(bytes.Buffer)
	tw := tar.NewWriter(buf)
	imageName = utils.ORGANIZATION + utils.FileNameWithoutExtension(filepath.Base(path))
	defer tw.Close()
	dockerFile := "Dockerfile"
	dockerFileReader, err := os.Open(filepath.Join(dest_path, "Dockerfile"))
	utils.ErrorHandler(err)
	readDockerFile, err := ioutil.ReadAll(dockerFileReader)
	utils.ErrorHandler(err)
	tarHeader := &tar.Header{
		Name: dockerFile,
		Size: int64(len(readDockerFile)),
	}
	err = tw.WriteHeader(tarHeader)
	utils.ErrorHandler(err)

	_, err = tw.Write(readDockerFile)
	utils.ErrorHandler(err)

	dockerFileTarReader := bytes.NewReader(buf.Bytes())
	imageBuildResponse, err := cli.ImageBuild(
		ctx,
		dockerFileTarReader,
		types.ImageBuildOptions{
			Context:    dockerFileTarReader,
			Tags:       []string{imageName},
			Dockerfile: dockerFile,
			BuildArgs:  map[string]*string{"EXPLOIT_URL": &remote_exploit},
			Remove:     true})

	utils.ErrorHandler(err)
	defer imageBuildResponse.Body.Close()

	// Print to standard output
	_, err = io.Copy(os.Stdout, imageBuildResponse.Body)
	utils.ErrorHandler(err)
	return
}

func RunContainer(imageName string) {
	ctx := context.Background()
	cli := Init()
	utils.Log("Create container")
	resp, err := cli.ContainerCreate(ctx, &container.Config{
		Image: imageName,
		Tty:   true}, &container.HostConfig{AutoRemove: true}, nil, nil, filepath.Base(imageName))
	utils.ErrorHandler(err)
	utils.Log("Start container")
	err = cli.ContainerStart(ctx, resp.ID, types.ContainerStartOptions{})
	utils.ErrorHandler(err)
	statusCh, errCh := cli.ContainerWait(ctx, resp.ID, container.WaitConditionNotRunning)
	fmt.Println(statusCh)
	select {
	case err := <-errCh:
		utils.ErrorHandler(err)
	case <-statusCh:
	}
	out, err := cli.ContainerLogs(ctx, resp.ID, types.ContainerLogsOptions{ShowStdout: true})
	utils.ErrorHandler(err)
	stdcopy.StdCopy(os.Stdout, os.Stderr, out)
}
